<?xml version="1.0" encoding="UTF-8" standalone="yes"?>

<?component error="true" debug="true"?>
<component>
<registration
	description="WSC for simplifying import JScript Library/Source code"
	progid="SLV.JS.Import"
	version="1"
	classid="{5183B7A6-9D7D-4ED7-8CF7-48E832C8DAD1}">
</registration>

<public>
<comment>
	LICENSE	GPLv3
	@file:	"slv_js_import.wsc"
	19:02 30.03.2014	begin project

	Author:	Svyatoslav Skriplyonok (Simvesel/Simron)
</comment>

	<method name="fn_import"/>
	<property name="xasOwnPath" internalName="g_asOwnPath"/>
	<property name="xasLibDirPath" internalName="g_asLibDirPath"/>
</public>

<resource id="rsrc_code_main"><![CDATA[
"use strict";

var g_cApp = {};
g_cApp.xasAbsolutePath = g_asLibDirPath;

function general_inc( jsFile )
{
	var f, masData;
	f = g_fso.OpenTextFile( jsFile );
	masData = f.ReadAll();
	f.Close();

	return masData;
}

function g_inc( jsFile )
{
	return general_inc( g_cApp.xasAbsolutePath + jsFile );
}

function fn_get_app_instance()
{
	return g_cApp;
}

]]></resource>

<resource id="rsrc_code_for_r_inc"><![CDATA[
var g_ws = WScript,
		g_fso = new ActiveXObject( "Scripting.FileSystemObject" ),
		g_sh = new ActiveXObject( "WScript.Shell" );

g_cApp.xasAppName = g_fso.GetBaseName( g_ws.ScriptName );
g_cApp.xasRelativePath = g_fso.GetParentFolderName( g_ws.ScriptFullName ) + "/";

function r_inc( jsFile )
{
	return general_inc( g_cApp.xasRelativePath + jsFile );
}

]]></resource>

<object id="g_sh" progid="WScript.Shell"/>
<object id="g_fso" progid="Scripting.FileSystemObject"/>

<script language="JScript"><![CDATA[
"use strict";

// HKLM\\SOFTWARE\\Classes\\CLSID\\
var g_asOwnPath = g_sh.RegRead( "HKCR\\CLSID\\{5183B7A6-9D7D-4ED7-8CF7-48E832C8DAD1}\\ScriptletURL\\" );
g_asOwnPath = g_asOwnPath.replace( "file:///", "" );
g_asLibDirPath = g_fso.GetParentFolderName( g_asOwnPath ) + "/";


function getMainSource()
{
	var masCode = getResource( "rsrc_code_main" );

	return masCode.replace( "g_asLibDirPath", '"' + g_asLibDirPath + '"' );
};


function getR_incSource()
{
	return getResource( "rsrc_code_for_r_inc" );
};


eval( getMainSource() );

/*
Индекс с ранее обработанными алиасами
Массив алиасов, которые нужно заинклудить (сложных алиасов не должно быть!!!)
Последний элемент удалять из массива и передавать в рекурсивную функцию уменьшенный массив.
Последний элемент-имя файла добавлять в массив подключений с первоначальным алиасом.
*/

//JSON	http://stackoverflow.com/questions/2994577/is-there-a-publicly-available-cdn-that-hosts-json2
var g_vLibsAliases =
{
	"json": "json3_min.js", //"json2.js",
	"utils": "sys_utils.js",
	"exec": [ "utils", "exec_args_escape.js" ],
	"exec_wsh": [ "utils", "wsh_args_escape.js" ],
//	"recurv_00": [ "utils", "json-cfg", "recurv_00.js" ],
	"json-cfg": [ "json", "json-cfg.js" ], /* последний элемент -- имя файла */
	"dummy": ""
}

var g_cIndexProcessedLibsAlias = {};

var g_vLibImportStructure = [];

var g_bFisrtCallImport = true;
var g_vLibImportDeep;


// Create a new object, that prototypally inherits from the Error constructor.
function ImportError( message )
{
  this.name = "ImportError";
  this.message = message || "Default message...";
}
//ImportError.prototype = Error.prototype;
ImportError.prototype = new Error();
ImportError.prototype.constructor = ImportError;


/*
короткосложный_импорт => длиннопростой_импорт
*/
function deploy_complex_alias( mvAliases )
{
	if( g_vLibImportDeep > 99 )
	{
		throw new ImportError( "Too large import deep!" );
	}

	var i = 0, len = mvAliases.length;

	for( ; i < len; ++i )
	{
		var masAlias = mvAliases[ i ];
		var mcVal = g_cIndexProcessedLibsAlias[ masAlias ];
		if( mcVal === 1 )
		{
			continue;
		}

		mcVal = g_vLibsAliases[ masAlias ];

		if( typeof mcVal === 'string' )
		{
			g_cIndexProcessedLibsAlias[ masAlias ] = 1;
			g_vLibImportStructure.push( masAlias );
			g_vLibImportStructure.push( mcVal );
		}
//	else if( mcVal instanceof Array )
		else if( Object.prototype.toString.call( mcVal ) === '[object Array]' )
		{
			var masFileName = mcVal.pop();
			g_cIndexProcessedLibsAlias[ masAlias ] = 1;

			++g_vLibImportDeep;
			deploy_complex_alias( mcVal );

			g_vLibImportStructure.push( masAlias );
			g_vLibImportStructure.push( masFileName );
		}
		else
		{
			var err = new Error();
			throw new ImportError( "Unknown ALIAS type!\n\n" + err.stack );
		}

/*
throw {
    name:        "System Error",
    level:       "Show Stopper",
    message:     "Error detected. Please contact the system administrator.",
    htmlMessage: "Error detected. Please contact the <a href=\"mailto:sysadmin@acme-widgets.com\">system administrator</a>.",
    toString:    function(){return this.name + ": " + this.message;}
};
*/

	}
}


//=============================================================
function fn_import( masLibs )
{
	g_vLibImportDeep = 0;
	deploy_complex_alias( masLibs.split( " " ) );
	masLibs = null;

	var masSources = "";
	if( g_bFisrtCallImport )
	{
		g_bFisrtCallImport = false;

		masSources += getMainSource()
		masSources += getR_incSource();

// при первом вызове fn_import ВСЕГДА принудительно подключаем
		g_vLibImportStructure.unshift( "func_alias.js" );
		g_vLibImportStructure.unshift( "alias" ); // нулевой индекс будет
	}

	var masErrors = "", masErrAliases = "";
	var miErrCounter = 0, i = 0, len = g_vLibImportStructure.length;
	for( ; i < len; )
	{
		var masAlias = g_vLibImportStructure[ i++ ];
		var masFile = g_vLibImportStructure[ i++ ];

		var masOneFileSource;
		try
		{
			masOneFileSource = g_inc( masFile );
		}
		catch( cEx )
		{
			++miErrCounter;
			masOneFileSource = "";

			masErrAliases += masAlias + ' ';
			masErrors += '\n/*\n\t===============================\nError load "LIB-ALIAS"!\nAlias: "';
			masErrors += masAlias + '"\nFILE: "';
			masErrors += masFile + '"\n{{\nname: "';
			masErrors += cEx.name;

			masErrors += '"\nmessage: "';
			masErrors += cEx.message;

			masErrors += '"\nnumber: "';
			masErrors += cEx.number;

			masErrors += '"\ndescription: "';
			masErrors += cEx.description;

			masErrors += '"\n\nSTACK:\n';
			masErrors += cEx.stack;

			masErrors += '\n}}\n\t===============================\n*/\n';
/*
			masErrors += cEx.
			masErrors += cEx.
*/
		}

		masSources += masOneFileSource + '\n;;;;;;;\n';
	}


	if( miErrCounter !== 0 )
	{
		masSources += '\n\necho( "Import errors: ';
		masSources += miErrCounter;
		masSources += '\\nALIASES:\\n\\"';
		masSources += masErrAliases + '\\"';
		masSources += '" );\n';
		masSources += masErrors;
	}

	return masSources;
};


]]></script>
</component>